/*
Module : PING.CPP
Purpose: Implementation for an MFC wrapper class to encapsulate PING
Created: PJN / 10-06-1998
History: PJN / 23-06-1198 1) Now code can be compiled to use Winsock2 calls
                          instead of using the ICMP.DLL. This gives another of
                          advantages:

                          i)  Your using a API that MS has promised to continue to support.
                          ii) Internally the class calls QueryPerformanceCounter meaning that
                              you will get the highest resolution RTT's possible.

                          2) Also did a general tidy up of the code
                          3) Changed default timeout to 1 second
         PJN / 30-07-1998 1) Can now use both Winsock 2 calls and ICMP style
				                     calls at the same time with the use of 2 preprocessor directives
                          2) sample program now use generic entry point _tmain 
													3) Got rid of a 2 level 4 compiler warning
													4) Fixed a problem with the cleanup of ICMP dll usage
													5) Tidied up and optimized the usage of static variables
         PJN / 01-03-2000 1) Fixed a problem where I was incorrectly overwritting memory in          
                             the function FillIcmpData  
         PJN / 15-07-2001 1) Updated copyright information
                          2) Code now automatically pulls in the Winsock 2 libraries as and when needed
         PJN / 12-01-2002 1) Updated copyright information
                          2) Now initializes Winsock 2.0 instead of Winsock 2.1. Thanks to Lev Elbert
                          for spotting this problem.
         PJN / 24-02-2002 1) Winsock 2 code path now allows you to bind the socket to a specific NIC.
                          This can prove useful when you want to run a targeted ping request on a
                          mulithoned machine.
                          2) Tidied up the code in the sample application
                          3) Provide a complete set of command line options for the sample app. It
                          now provides almost a 1 - 1 implementation of the build in Ping options.
                          4) Completed reworked and recoded all the CPing code.
                          5) Client code is now responsible for initializing Winsock instead of 
                          having it embedded in the CPing code
         PJN / 05-05-2002 1) Now includes a EchoReplyStatus in CPingReply structure if CPING_NO_ICMP is not 
                          defined
         PJN / 21-11-2002 1. Fixed an issue in the calculation of the packet size when sending using 
                          raw sockets.
                          2. Default sample now uses a default TTL of 30
                          3. Changes the nPacketSize parameter to the Ping method to be nDataSize which is 
                          what it really is.
                          4. Reviewed all the TRACE messages for correctness
                          5. Made all the helper functions used by the code member functions of the class
                          6. General tidy up of the various defines
                          7. Winsock 2 version of ping now allows you to specify the sequence number of the 
                          packet. This allows the ping to exclude packets from the same process id which
                          are being generated by for example another thread.
                          8. Fixed a bug in the call to recvfrom. The receive buffer size was not being
                          specified correctly.
                          9. ICMP response packets from other processes are now ignored when waiting for 
                          an ICMP response
                          10. ICMP response packets from the same process but which have an incorrect 
                          sequence number are now ignored when waiting for an ICMP response.
                          11. Fix a resource leak of a socket when unexpected failures occur in the 
                          CPing::PingUsingWinsock function
         PJN / 10-03-2003 1. Fixed a bug where using PingUsingWinsock and setting the data size greater 
                          than 1004 appears to cause Winsock error 10040 - The datagram is too large to 
                          fit into the buffer and is truncated. Thanks to Paul Golightly for reported this
                          and provided the fix.
         PJN / 13-03-2003 1. Fixed a bug in CPing::IsSocketReadible in the setup of the timeval structure. 
                          Thanks to "InBloom Support" for reporting this.
         PJN / 23-11-2003 1. Fixed a level 4 warning in VC 6 in the function CPing::PingUsingWinsock.
         PJN / 12-04-2004 1. Fixed a bug in the declaration of h_len and version in the IP_HEADER structure. 
                          Also made the source and destination IP addresses longs instead of ints to avoid
                          any porting problems. Thanks to Yuh-Rong Leu for reporting this problem. 
                          2. Fixed a bug in PingUsingWinsock when a timeout occurs and it returns TRUE. 
                          Thanks to Yuh-Rong Leu for reporting this problem.
                          3. Updated the documentation to refer to using the value from GetCurrentThreadId()
                          for the nSequenceNumber parameter when calling the PingUsingWinsock function.
                          Again thanks to Yuh-Rong Leu for reporting this issue.
                          4. Fixed an issue in DecodeResponse where if bTryAgain was set to TRUE, the return
                          value was incorrectly also being set to TRUE. Thanks to Yuh-Rong Leu for reporting 
                          this issue. 
         PJN / 11-06-2005 1. Reviewed all TRACE statements for correctness. Thanks to "Grenal" for reporting
                          this issue.
                          2. Checked all premature return points in the codebase to ensure the last error 
                          value is preserved.
                          3. Fixed an unreferrenced variable in DecodeResponse function when code is compiled
                          with Visual Studio .NET 2003
         PJN / 31-07-2005 1. When sending a ping, the allowable size of the data in the packet 
                          can now be anywhere from 0 to 65500. Previosuly sending a ping using Winsock was
                          limited to a data size of 1024 and when using ICMP.dll, the size was limited to 255.
                          Thanks to Leon Luu for reporting this issue.
         PJN / 31-07-2005 1. Now the PingUsingICMP method using the versions provided in the IP Helper dll
                          namely "Iphlpapi.dll" before falling back to "ICMP.dll".
                          2. Tidied up the various ICMP defines by making them part of the _CPING_ICMP class
         PJN / 10-07-2006 1. Updated copyright details
                          2. The code now requires the Platform SDK if compiled using VC 6.
                          3. Integrated the functionality of _CPING_ICMP class into CPing
                          4. Optimized CPingReply constructor code
                          5. Code now uses newer C++ style casts instead of C style casts.
                          6. Addition of CPING_EXT_CLASS macro to allow the code to be easily added to an 
                          extension dll.
                          7. Code now uses newer C++ style casts instead of C style casts.
                          8. Updated the code to clean compile on VC 2005.
                          9. Updated documentation to use the same style as the web site.

Copyright (c) 1998 - 2005 by PJ Naughter (Web: www.naughter.com, Email: pjna@naughter.com)

All rights reserved.

Copyright / Usage Details:

You are allowed to include the source code in any product (commercial, shareware, freeware or otherwise) 
when your product is released in binary form. You are allowed to modify the source code in any way you want 
except you cannot modify the copyright details at the top of each module. If you want to distribute source 
code with your application, then you are only allowed to distribute versions released by the author. This is 
to maintain a single distribution point for the source code. 

*/

/////////////////////////////////  Includes  //////////////////////////////////

#include "stdafx.h"
#ifndef __AFXPRIV_H__
#pragma message("To avoid this message please put AFXPRIV.H in your PCH (normally stdafx.h)")
#include <afxpriv.h>
#endif
#include "ping.h"


/////////////////////////////////  Macros & Defines ///////////////////////////

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#ifndef CPING_NO_WINSOCK2
  #define IP_TOS                      3     //IP type of service and precee
  #define IP_TTL                      4     //IP time to live
  #define IP_DONTFRAGMENT             14    //don't fragment IP datagrams
  #define MAX_CPING_ICMP_DATA_SIZE    65500 //Maximum icmp packet size
  #define MAX_CPING_ICMP_PACKET_SIZE  (MAX_CPING_ICMP_DATA_SIZE + sizeof(ICMP_HEADER))
  #define CPING_ICMP_ECHO_REPLY       0
  #define CPING_ICMP_ECHO_REQUEST     8
  #define CPING_ICMP_DEST_UNREACHABLE 3
  #define CPING_ICMP_TTL_EXPIRE       11
#endif


///////////////////////////////// Implementation //////////////////////////////

CPingReply::CPingReply() : RTT(0),
                           EchoReplyStatus(0)
{
  Address.S_un.S_addr = 0;
}


CPing::CPing()
{
#ifndef CPING_NO_ICMP
	//First try the IP Helper library
	m_hIcmp = LoadLibrary(_T("Iphlpapi.dll"));
	if (m_hIcmp)
  {
	  //Retrieve pointers to the functions in the ICMP dll
	  m_pIcmpCreateFile = reinterpret_cast<LPICMPCREATEFILE>(GetProcAddress(m_hIcmp,L"IcmpCreateFile"));
	  m_pIcmpSendEcho = reinterpret_cast<LPICMPSENDECHO>(GetProcAddress(m_hIcmp,L"IcmpSendEcho"));
	  m_pIcmpCloseHandle = reinterpret_cast<LPICMPCLOSEHANDLE>(GetProcAddress(m_hIcmp,L"IcmpCloseHandle"));

	  if (m_pIcmpCreateFile == NULL || m_pIcmpSendEcho == NULL ||	m_pIcmpCloseHandle == NULL)
    {
		  TRACE(_T("CPing::CPing, Could not find the required functions in the Iphlpapi dll, will try ICMP.dll\n"));

      FreeLibrary(m_hIcmp);
      m_hIcmp = NULL;
      m_pIcmpCreateFile = NULL; 
      m_pIcmpSendEcho = NULL;
      m_pIcmpCloseHandle = NULL;
    }
  }

  if (m_hIcmp == NULL)
  {
    TRACE(_T("CPing::CPing, Falling back to trying ICMP DLL\n"));

	  //If not fall back to using the ICMP library
	  m_hIcmp = LoadLibrary(_T("ICMP.DLL"));
	  if (m_hIcmp)
    {
	    //Retrieve pointers to the functions in the ICMP dll
	    m_pIcmpCreateFile = reinterpret_cast<LPICMPCREATEFILE>(GetProcAddress(m_hIcmp,L"IcmpCreateFile"));
	    m_pIcmpSendEcho = reinterpret_cast<LPICMPSENDECHO>(GetProcAddress(m_hIcmp,L"IcmpSendEcho"));
	    m_pIcmpCloseHandle = reinterpret_cast<LPICMPCLOSEHANDLE>(GetProcAddress(m_hIcmp,L"IcmpCloseHandle"));

	    if (m_pIcmpCreateFile == NULL || m_pIcmpSendEcho == NULL ||	m_pIcmpCloseHandle == NULL)
      {
		    TRACE(_T("CPing::CPing, Could not find the required functions in the ICMP.dll\n"));

        FreeLibrary(m_hIcmp);
        m_hIcmp = NULL;
        m_pIcmpCreateFile = NULL; 
        m_pIcmpSendEcho = NULL;
        m_pIcmpCloseHandle = NULL;
      }
    }
    else
		  TRACE(_T("CPing::CPing, Could not load up the ICMP dll\n"));
  }
#endif
}

CPing::~CPing()
{
#ifndef CPING_NO_ICMP
	if (m_hIcmp)
	{
		FreeLibrary(m_hIcmp);
		m_hIcmp = NULL;
  }
#endif
}

#ifndef CPING_NO_WINSOCK2
BOOL CPing::Bind(SOCKET socket, LPCTSTR pszLocalBoundAddress)
{
	USES_CONVERSION;

  //Setup the structure used in sdk "bind" calls
  SOCKADDR_IN sockLocalAddress;
  ZeroMemory(&sockLocalAddress, sizeof(sockLocalAddress));
  sockLocalAddress.sin_family = AF_INET;
  sockLocalAddress.sin_port = htons(0);

  //Convert to an ASCII string
  LPSTR lpszAsciiLocalAddress = T2A(const_cast<LPTSTR>(pszLocalBoundAddress));
  sockLocalAddress.sin_addr.s_addr = inet_addr(lpszAsciiLocalAddress);

	//If the address is not dotted notation, then do a DNS 
	//lookup of it.
	if (sockLocalAddress.sin_addr.s_addr == INADDR_NONE)
	{
		LPHOSTENT lphost;
		lphost = gethostbyname(lpszAsciiLocalAddress);
		if (lphost != NULL)
			sockLocalAddress.sin_addr.s_addr = (reinterpret_cast<LPIN_ADDR>(lphost->h_addr))->s_addr;
		else
      return FALSE; 
  }

  //Finally call the SDK "bind" function
  return (bind(socket, reinterpret_cast<sockaddr*>(&sockLocalAddress), sizeof(sockLocalAddress)) != SOCKET_ERROR);
}

BOOL CPing::DecodeResponse(LPIP_HEADER pIPHeader, int nBytes, sockaddr_in* from, USHORT nExpectedSequenceNumber, BOOL& bTryAgain)
{
  USES_CONVERSION;
#ifndef _DEBUG
  UNUSED(from);
#endif  

  //By default, attempt retries
  bTryAgain = TRUE;

  //Jump to the ICMP Header
	int nIpHdrlen = pIPHeader->h_len * 4; //Number of 32-bit words*4 = bytes
	LPICMP_HEADER pIcmpHdr = reinterpret_cast<LPICMP_HEADER>((reinterpret_cast<char*>(pIPHeader)) + nIpHdrlen);

  //Not enough data recieved
	if (nBytes < (static_cast<int>(nIpHdrlen + sizeof(ICMP_HEADER))))
	{
		TRACE(_T("CPing::DecodeResponse, Received too few bytes in ICMP response packet from address:%s\n"), A2T(inet_ntoa(from->sin_addr)));
    SetLastError(ERROR_UNEXP_NET_ERR);
    return FALSE;
	}

  //Check it is the same id as we sent
	if (pIcmpHdr->i_id != static_cast<USHORT>(GetCurrentProcessId())) 
	{
		TRACE(_T("CPing::DecodeResponse, Received an ICMP response packet for some other process: ID:%d\n"), pIcmpHdr->i_id);
		return FALSE;
	}

  //We will try again if the packet is not the correct sequence number
  bTryAgain = (nExpectedSequenceNumber != pIcmpHdr->i_seq);
  if (bTryAgain)
    return FALSE;

  //Check if it is an ICMP_ECHOREPLY packet
	if (pIcmpHdr->i_type != CPING_ICMP_ECHO_REPLY)
	{
		TRACE(_T("CPing::DecodeResponse, Non-echo reply type field in ICMP reponse packet, Value:%d\n"), pIcmpHdr->i_type);
    SetLastError(ERROR_UNEXP_NET_ERR);
		return FALSE;
	}

  return TRUE;
}

//generate an IP checksum based on a given data buffer
USHORT CPing::GenerateIPChecksum(USHORT* pBuffer, int nSize)
{
  unsigned long cksum = 0;

  while (nSize > 1) 
	{
	  cksum += *pBuffer++;
	  nSize -= sizeof(USHORT);
  }
  
  if (nSize) 
	  cksum += *(reinterpret_cast<UCHAR*>(pBuffer));

  cksum = (cksum >> 16) + (cksum & 0xffff);
  cksum += (cksum >> 16);
  return static_cast<USHORT>(~cksum);
}

//Fill up the ICMP packet with defined values
void CPing::FillIcmpData(LPICMP_HEADER pIcmp, int nPacketSize, USHORT nSequenceNumber)
{
  pIcmp->i_type    = CPING_ICMP_ECHO_REQUEST;
  pIcmp->i_code    = 0;
  pIcmp->i_id      = static_cast<USHORT>(GetCurrentProcessId());
  pIcmp->i_seq     = nSequenceNumber;
  pIcmp->i_cksum   = 0;
  pIcmp->timestamp = GetTickCount();
 
  //Set up the data which will be sent
  char* pData = (reinterpret_cast<char*>(pIcmp)) + sizeof(ICMP_HEADER);
  memset(pData, 'E', nPacketSize - sizeof(ICMP_HEADER));

  //Generate the checksum
  pIcmp->i_cksum = GenerateIPChecksum(reinterpret_cast<USHORT*>(pIcmp), nPacketSize);
}

BOOL CPing::PingUsingWinsock(LPCTSTR pszHostName, CPingReply& pr, UCHAR nTTL, DWORD dwTimeout, WORD wDataSize, UCHAR nTOS, BOOL bDontFragment, LPCTSTR pszLocalBoundAddress, USHORT nSequenceNumber) const
{
	USES_CONVERSION;

  //Use the High performace counter to get an accurate RTT
  LARGE_INTEGER Frequency;
	Frequency.QuadPart = 0;
  if (!QueryPerformanceFrequency(&Frequency))
  {
    TRACE(_T("CPing::PingUsingWinsock, Failed to get the high performance counter frequency\n"));
    return FALSE;
  }
  __int64 nTimerFrequency = Frequency.QuadPart;

  //Resolve the address of the host to connect to
  sockaddr_in dest;
  memset(&dest,0,sizeof(dest));
	LPSTR lpszAscii = T2A(const_cast<LPTSTR>(pszHostName));
  unsigned long addr = inet_addr(lpszAscii);
	if (addr == INADDR_NONE)
	{
		//Not a dotted address, then do a lookup of the name
		hostent* hp = gethostbyname(lpszAscii);
		if (hp)
    {
      memcpy(&dest.sin_addr, hp->h_addr, hp->h_length);
  	  dest.sin_family = hp->h_addrtype;
    }
    else
	  {
		  TRACE(_T("CPing::PingUsingWinsock, Could not resolve the host name %s\n"), pszHostName);
		  return FALSE;
    }
  }
  else
  {
    dest.sin_addr.s_addr = addr;
    dest.sin_family = AF_INET;
  }

  //Create the raw socket
  SOCKET sockRaw = WSASocket(AF_INET, SOCK_RAW, IPPROTO_ICMP, NULL, 0, 0);
  if (sockRaw == INVALID_SOCKET) 
	{
	  TRACE(_T("CPing::PingUsingWinsock, Failed to create a raw socket\n"));
	  return FALSE;
  }

  //Bind to the local address if need be
  if (pszLocalBoundAddress && _tcslen(pszLocalBoundAddress))
  {
    if (!Bind(sockRaw, pszLocalBoundAddress))
    {
      DWORD dwError = GetLastError();
  		TRACE(_T("CPing::PingUsingWinsock, Failed to bind to specified address %s\n"), pszLocalBoundAddress);
      closesocket(sockRaw);
      SetLastError(dwError);
      return FALSE;
    }
  }

  //Set the TTL on the socket  
  int nTempTTL = nTTL;
  if (setsockopt(sockRaw, IPPROTO_IP, IP_TTL, reinterpret_cast<char*>(&nTempTTL), sizeof(nTempTTL)) == SOCKET_ERROR)
  {
    DWORD dwError = GetLastError();
  	TRACE(_T("CPing::PingUsingWinsock, Failed to set the TTL value on the socket\n"));
    closesocket(sockRaw);
    SetLastError(dwError);
    return FALSE;
  }

  //Set the TOS on the socket  
  int nTempTos = nTOS;
  if (setsockopt(sockRaw, IPPROTO_IP, IP_TOS, reinterpret_cast<char*>(&nTempTos), sizeof(nTempTos)) == SOCKET_ERROR)
  {
    DWORD dwError = GetLastError();
  	TRACE(_T("CPing::PingUsingWinsock, Failed to set the TOS value on the socket\n"));
    closesocket(sockRaw);
    SetLastError(dwError);
    return FALSE;
  }

  //Set the Don't Fragment flag on the socket  
  if (bDontFragment)
  {
    if (setsockopt(sockRaw, IPPROTO_IP, IP_DONTFRAGMENT, reinterpret_cast<char*>(&bDontFragment), sizeof(bDontFragment)) == SOCKET_ERROR)
    {
      DWORD dwError = GetLastError();
  	  TRACE(_T("CPing::PingUsingWinsock, Failed to set the Don't Fragment value on the socket\n"));
      closesocket(sockRaw);
      SetLastError(dwError);
      return FALSE;
    }
  }
 
  //Allocate the ICMP packet
  int nPacketSize = sizeof(ICMP_HEADER) + min(MAX_CPING_ICMP_DATA_SIZE, wDataSize);
  char* pICMP = new char[nPacketSize];
  FillIcmpData(reinterpret_cast<LPICMP_HEADER>(pICMP), nPacketSize, nSequenceNumber);

  //Get the tick count prior to sending the packet
  LARGE_INTEGER TimerTick;
  VERIFY(QueryPerformanceCounter(&TimerTick));
  __int64 nStartTick = TimerTick.QuadPart;

  //Send of the packet
	int nWrote = sendto(sockRaw, pICMP, nPacketSize, 0, reinterpret_cast<sockaddr*>(&dest), sizeof(dest));
	if (nWrote == SOCKET_ERROR)
	{
    DWORD dwError = GetLastError();
		TRACE(_T("CPing::PingUsingWinsock, sendto failed\n"));
    delete [] pICMP;
    closesocket(sockRaw);
    SetLastError(dwError);
    return FALSE;
	}

  //allocate the recv buffer
  int nReceiveBufferSize = MAX_CPING_ICMP_PACKET_SIZE + sizeof(IP_HEADER);
  LPIP_HEADER pRecvBuf = reinterpret_cast<LPIP_HEADER>(new char[nReceiveBufferSize]);
  BOOL bReadable;
  sockaddr_in from;
  memset(&from, 0, sizeof(from));
  int nFromlen = sizeof(from);
  int nRead = 0;

  //Loop around waiting for the correct response
  BOOL bContinueReading = TRUE;
  BOOL bSuccess = FALSE;
  while (bContinueReading)
  {
    //Allow the specified timeout
    if (IsSocketReadible(sockRaw, dwTimeout, bReadable))
    {
      if (bReadable)
      {
        //Receive the response
	      nRead = recvfrom(sockRaw, reinterpret_cast<char*>(pRecvBuf), nReceiveBufferSize, 0, reinterpret_cast<sockaddr*>(&from), &nFromlen);

        //Now check the return response from recvfrom
	      if (nRead != SOCKET_ERROR)
        {
          //Decode the response we got back
         	bSuccess = DecodeResponse(pRecvBuf, nRead, &from, nSequenceNumber, bContinueReading);
        }
      }
      else
      {
		    TRACE(_T("CPing::PingUsingWinsock, timeout occured while awaiting recvfrom\n"));
        closesocket(sockRaw);

        delete [] pICMP;
        delete [] pRecvBuf;
          
        closesocket(sockRaw);

        //set the error to timed out
        SetLastError(WSAETIMEDOUT);

		    return FALSE;
      }
    }
    else
    {
      DWORD dwError = GetLastError();
		  TRACE(_T("CPing::PingUsingWinsock, IsReadible call failed\n"));
      delete [] pICMP;
      delete [] pRecvBuf;
      closesocket(sockRaw);
      SetLastError(dwError);
		  return FALSE;
    }
  }

  //Get the current tick count
  QueryPerformanceCounter(&TimerTick);

  //Return the values in the CPingReply instance
  if (bSuccess)
  {
    pr.Address = from.sin_addr;
    pr.RTT = static_cast<ULONG>((TimerTick.QuadPart - nStartTick) * 1000 / nTimerFrequency);
  }

  //Free up the memory we allocated
  delete [] pICMP;
  delete [] pRecvBuf;

  //Don't forget to release out socket
  closesocket(sockRaw);

  //return the status
	return bSuccess;
}
#endif //CPING_NO_WINSOCK2

BOOL CPing::IsSocketReadible(SOCKET socket, DWORD dwTimeout, BOOL& bReadible)
{
  timeval timeout;
  timeout.tv_sec =  dwTimeout / 1000;
  timeout.tv_usec = (dwTimeout % 1000) * 1000;
  fd_set fds;
  FD_ZERO(&fds);
  FD_SET(socket, &fds);
  int nStatus = select(0, &fds, NULL, NULL, &timeout);
  if (nStatus == SOCKET_ERROR)
    return FALSE;
  else
  {
    bReadible = !(nStatus == 0);
    return TRUE;
  }
}

#ifndef CPING_NO_ICMP
BOOL CPing::PingUsingICMP(LPCTSTR pszHostName, CPingReply& pr, UCHAR nTTL, DWORD dwTimeout, WORD wDataSize, UCHAR nTOS, BOOL bDontFragment) const
{
	USES_CONVERSION;

	//Make sure ICMP dll is available
	if (m_hIcmp == NULL)
  {
    TRACE(_T("CPing::PingUsingICMP, ICMP dll is not available\n"));
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
	  return FALSE;
  }

	LPSTR lpszAscii = T2A(const_cast<LPTSTR>(pszHostName));
	//Convert from dotted notation if required
	unsigned long	addr = inet_addr(lpszAscii);
	if (addr == INADDR_NONE)
	{
		//Not a dotted address, then do a lookup of the name
		hostent* hp = gethostbyname(lpszAscii);
		if (hp)
			memcpy(&addr, hp->h_addr, hp->h_length);
		else
		{
			TRACE(_T("CPing::PingUsingICMP, Could not resolve the host name %s\n"), pszHostName);
			return FALSE;
		}
	}

  //Create the ICMP handle
  ASSERT(m_pIcmpCreateFile);
	HANDLE hIP = m_pIcmpCreateFile();
	if (hIP == INVALID_HANDLE_VALUE)
	{
		TRACE(_T("CPing::PingUsingICMP, Could not get a valid ICMP handle\n"));
		return FALSE;
	}

  //Set up the option info structure
	IP_OPTION_INFORMATION OptionInfo;
	memset(&OptionInfo, 0, sizeof(OptionInfo));
	OptionInfo.Ttl = nTTL;
  OptionInfo.Tos = nTOS;
  if (bDontFragment)
    OptionInfo.Flags = IP_FLAG_DF;

  //Set up the data which will be sent
  unsigned char* pBuf = new unsigned char[wDataSize];
  memset(pBuf, 'E', wDataSize);

	//Do the actual Ping
  DWORD dwReplySize = sizeof(ICMP_ECHO_REPLY) + max(wDataSize, 8);
  unsigned char* pReply = new unsigned char[dwReplySize];
	ICMP_ECHO_REPLY* pEchoReply = reinterpret_cast<ICMP_ECHO_REPLY*>(pReply);
  ASSERT(m_pIcmpSendEcho);
  DWORD nRecvPackets = m_pIcmpSendEcho(hIP, addr, pBuf, wDataSize, &OptionInfo, pReply, dwReplySize, dwTimeout);

  //Check we got the packet back
  BOOL bSuccess = (nRecvPackets == 1);

  //Check the data we got back is what was sent
  if (bSuccess)
  {
    char* pReplyData = static_cast<char*>(pEchoReply->Data);
    for (int i=0; i<pEchoReply->DataSize && bSuccess; i++)
      bSuccess = (pReplyData[i] == 'E');

    if (!bSuccess)
    {
      TRACE(_T("CPing::PingUsingICMP, Could not get a valid ICMP response\n"));
      SetLastError(ERROR_UNEXP_NET_ERR);
    }
  }

  //Close the ICMP handle
  ASSERT(m_pIcmpCloseHandle);
	m_pIcmpCloseHandle(hIP);

	if (bSuccess)
	{
    //Ping was successful, copy over the pertinent info
    //into the return structure
		pr.Address.S_un.S_addr = pEchoReply->Address;
	  pr.RTT = pEchoReply->RoundTripTime;
    pr.EchoReplyStatus = pEchoReply->Status;
	}

  //Free up the memory we allocated
  delete [] pBuf;
  delete [] pReply;

  //return the status
	return bSuccess; 
}
#endif //CPING_USE_ICMP
